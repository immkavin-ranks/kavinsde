>An exception is an abnormal condition that arises in a code sequence at run time. In other words, an exception is a run-time error.
# Exception-Handling Fundamentals

A Java exception is an object that describes an exceptional (that is, error) condition that has occurred in a piece of code. When an exceptional condition arises, an object representing that exception is created and thrown in the method that caused the error.

Exceptions can be generated by the Java run-time system, or they can be manually generated by your code.

>Java exception handling is managed via five keywords: try, catch, throw, throws, and finally.

Here is how they work,
* Program statements that you want to monitor for exceptions are contained within a **try** block. 
* If an exception occurs within the try block, it is thrown. Your code can catch this exception (using **catch**) and handle it in some rational manner. System-generated exceptions are automatically thrown by the Java run-time system. 
* To manually throw an exception, use the keyword **throw**. 
* Any exception that is thrown out of a method must be specified as such by a **throws** clause. 
* Any code that absolutely must be executed after a try block completes is put in a **finally** block.

This is the general form of an exception-handling block:

```java
try {
 // block of code to monitor for errors
}
catch (ExceptionType1 exOb) {
// exception handler for ExceptionType1
}
catch (ExceptionType2 exOb) {
// exception handler for ExceptionType2
}
// ...
finally {
// block of code to be executed after try block ends
}
```
Here, `ExceptionType` is the type of exception that has occurred.

# Exception Types

> All exception types are subclasses of the built-in class Throwable. Thus, Throwable is at the top of the exception class hierarchy. Immediately below Throwable are two subclasses that partition exceptions into two distinct branches.

The top-level exception hierarchy is shown here:

![Pasted image 20240906082344](assets/Pasted%20image%2020240906082344.png)

* One branch is headed by **`Exception`**. This class is used for exceptional conditions that user programs should catch. This is also the class that you will subclass to create your own **custom exception types**. There is an important subclass of Exception, called `RuntimeException`.
* Exceptions of this type are automatically defined for the programs that you write and include things such as **division by zero** and **invalid array indexing**.
* The other branch is topped by `Error`, which defines exceptions that are not expected to be caught under normal circumstances by your program. Exceptions of type Error are used by the Java run-time system to indicate errors having to do with the run-time environment, itself. **Stack overflow** is an example of such an error.
# Uncaught Exceptions

>What happens when you don’t handle exceptions?

```java
class Exc0 {
	public static void main(String args[]) {
		int d = 0;
		int a = 42 / d;
	}
}
```

> Any exception that is not caught by your program will ultimately be processed by the **default handler**.

* When the Java run-time system detects the attempt to **divide by zero**, it constructs a new exception object and then *throws* this exception. This causes the execution of `Exc0` to stop, because once an exception has been thrown, it must be caught by an exception handler and dealt with immediately. 
* In this example, we haven’t supplied any exception handlers of our own, so the exception is caught by the **default handler** provided by the Java run-time system. 
* The default handler displays a string describing the exception, prints a **stack trace** from the point at which the exception occurred, and terminates the program.

Here is the exception generated when this example is executed:
```stacktrace
 java.lang.ArithmeticException: / by zero
 at Exc0.main(Exc0.java:4)
```

>The stack trace will always show the sequence of method invocations that led up to the error.

```java
class Exc1 {
	static void subroutine() {
		int d = 0;
		int a = 10 / d;
	}
	public static void main(String args[]) {
		Exc1.subroutine();
	}
}
```

The resulting stack trace from the default exception handler shows how the entire call 
stack is displayed:
```stack trace
 java.lang.ArithmeticException: / by zero
 at Exc1.subroutine(Exc1.java:4)
 at Exc1.main(Exc1.java:7)
```
As you can see, the bottom of the stack is main’s line 7, which is the call to subroutine( ), which caused the exception at line 4. The call stack is quite useful for **debugging**, because it pinpoints the precise sequence of steps that led to the error.
# Using try and catch

To guard against and handle a run-time error, simply enclose the code that you want to monitor inside a try block. Immediately following the try block, include a catch clause that specifies the exception type that you wish to catch.

```java
class Exc2 {
	public static void main(String args[]) {
		int d, a;
		try { // monitor a block of code.
			d = 0;
			a = 42 / d;
			System.out.println("This will not be printed.");
		} catch (ArithmeticException e) { // catch divide-by-zero error
			System.out.println("Division by zero.");
		}
		System.out.println("After catch statement.");
	}
}
```
```output
Division by zero.
After catch statement.
```

>Once an exception is thrown, program control transfers out of the try block into the catch block. Put differently, catch is not “called,” so execution **never** “returns” to the try block from a catch.

*The goal of most well-constructed catch clauses should be to resolve the exceptional condition and then continue on as if the error had never happened.*

```java
// Handle an exception and move on.
import java.util.Random;
class HandleError {
	public static void main(String args[]) {
		int a=0, b=0, c=0;
		Random r = new Random();
		for(int i=0; i<32000; i++) {
			try {
				b = r.nextInt();
				c = r.nextInt();
				a = 12345 / (b/c);
			} catch (ArithmeticException e) {
				System.out.println("Division by zero.");
				a = 0; // set a to zero and continue
			}
		System.out.println("a: " + a);
		}
	}
}
```
## Displaying a Description of an Exception

Throwable overrides the `toString`( ) method (defined by Object) so that it returns a string containing a description of the exception.

```java
catch (ArithmeticException e) {
	System.out.println("Exception: " + e);
	a = 0; // set a to zero and continue
}
```
```
Exception: java.lang.ArithmeticException: / by zero
```

While it is of no particular value in this context, the ability to display a description of 
an exception is valuable in other circumstances—particularly when you are experimenting 
with exceptions or when you are debugging.
# Multiple catch Clauses
